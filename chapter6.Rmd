# 6 Analysis of longitudinal data

```{r, echo=FALSE}
# *Describe the work you have done this week and summarize your learning.*
#
#- Describe your work and results clearly. 
#- Assume the reader has an introductory course level understanding of writing and reading R code as well as statistical methods.
#- Assume the reader has no previous knowledge of your data or the more advanced methods you are using.
```

    Intro from the IODS MOOC-page:  
    
After working hard with multivariate, mostly explorative, even heuristic techniques that are common in data science, the last topic of the course will take us back in the task of building **statistical models**.  

The new challenge is that the data will include **two types of dependencies simultaneously**: In addition to the correlated variables that we have faced with all models and methods so far, the **observations of the data will also be correlated with each other**.  

Usually, we can assume that the observations are not correlated - instead, they are assumed to be *independent* of each other. However, in **longitudinal settings this assumption seldom holds, because we have multiple observations or measurements of the same individuals. The concept of repeated measures highlights this phenomenon that is actually quite typical in many applications. Both types of dependencies (variables and observations) must be taken into account; otherwise the models will be biased**.  

To analyze this kind of data sets, we will focus on a single class of methods, called **linear mixed effects models** that can cope quite nicely with the setting described above.  

Before we consider two examples of mixed models, namely the random intercept model and the random intercept and slope model, we will learn how to wrangle **longitudinal data in wide form and long form**, take a look at some **graphical displays of longitudinal data**, and try a simple *summary* measure approach that may sometimes provide a useful first step in these challenges. In passing, we “violently” apply the usual “fixed” models (although we know that they are not the right choice here) in order to compare the results and see the consequences of making invalid assumptions. 

# 6.1 Graphical displays and summary measure approach

## 6.1.1 Introducing the RATS dataset

>This chapter's dataset originates from the United Nations Development Programme. The Human Development Index (HDI) was created for assessig the development of a country in another way than just economic growth. More information can be found on their [general data page](http://hdr.undp.org/en/content/human-development-index-hdi) and on [pdf about calculating the human development indices](http://hdr.undp.org/sites/default/files/hdr2015_technical_notes.pdf). 
```{r}
# Read in the data in long format, L for long  

RATS <- read.table("./data/RATS.txt", header=TRUE)
RATSL <- read.table("./data/RATSL.txt", header=TRUE)
# factor the categorical variables ID and group
RATSL$ID <- as.factor(RATSL$ID)
RATSL$Group <- as.factor(RATSL$Group)
```

## 6.1.2 Graphical displays of longitudinal data

```{r}
#Access the package ggplot2
library(ggplot2)
# Draw the plot
ggplot(RATSL, aes(x = Time, y = Weight, linetype = ID)) +
  geom_line() +
  scale_linetype_manual(values = rep(1:10, times=4)) +
  facet_grid(. ~ Group, labeller = label_both) +
  theme(legend.position = "none") + 
  scale_y_continuous(limits = c(min(RATSL$Weight), max(RATSL$Weight)))
```

Standardization

```{r, message=FALSE}
# dplyr, tidyr and ggplot2 packages and BPRSL are available
library(tidyr)
library(dplyr)
# Standardise the variable bprs
RATSL <- RATSL %>%
  group_by(Time) %>%
  mutate(stdWeight = (Weight - mean(Weight))/sd(Weight) ) %>%
  ungroup()
# Glimpse the data
glimpse(RATSL)
# Plot again with the standardised Weight
ggplot(RATSL, aes(x = Time, y = stdWeight, linetype = ID)) +
  geom_line() +
  scale_linetype_manual(values = rep(1:10, times=4)) +
  facet_grid(. ~ Group, labeller = label_both) +
  scale_y_continuous(name = "standardized Weights")
```

```{r}
# dplyr, tidyr & ggplot2 packages and BPRSL are available
# Number of weeks, baseline (week 0) included
n <- RATSL$Time %>% unique() %>% length()
# Summary data with mean and standard error of bprs by treatment and week 
RATSS <- RATSL %>%
  group_by(Group, Time) %>%
  summarise( mean = mean(Weight), se = sd(Weight)/sqrt(n) ) %>%
  ungroup()
# Glimpse the data
glimpse(RATSS)
# Plot the mean profiles
ggplot(RATSS, aes(x = Time, y = mean, linetype = Group, shape = Group)) +
  geom_line() +
  scale_linetype_manual(values = c(1,2,3)) +
  geom_point(size=3) +
  scale_shape_manual(values = c(1,2,3)) +
  #geom_errorbar(aes(ymin=mean-se, ymax=mean+se, linetype="1"), width=0.3) +
  theme(legend.position = c(0.9,0.5)) +
  scale_y_continuous(name = "mean(Weight) +/- se(Weight)")

```

```{r}
# dplyr, tidyr & ggplot2 packages and BPRSL are available
# Create a summary data by treatment and subject with mean as the summary variable (ignoring baseline week 0).
RATSL8S <- RATSL %>%
  filter(Time > 1) %>%
  group_by(Group, ID) %>%
  summarise( mean=mean(Weight) ) %>%
  ungroup()
# Glimpse the data
glimpse(RATSL8S)
# Create a new data by filtering the outlier and adjust the ggplot code the draw the plot again with the new data
RATSL8S1 <- RATSL8S %>% filter(mean<70)
# Draw a boxplot of the mean versus treatment
ggplot(RATSL8S1, aes(x = Group, y = mean)) +
  geom_boxplot() +
  stat_summary(fun.y = "mean", geom = "point", shape=23, size=4, fill = "white") +
  scale_y_continuous(name = "mean(Weight), Time 1-8") # not weeks but.. days?
```



```{r}
# dplyr, tidyr & ggplot2 packages and BPRSL8S & BPRSL8S1 data are available
# Perform a two-sample t-test
# t.test(mean ~ Group, data = RATSL8S1, var.equal = TRUE)
# Add the baseline from the original data as a new variable to the summary data
RATSL8S2 <- RATSL8S %>%
  mutate(baseline = RATS$WD1)
# Fit the linear model with the mean as the response 
fit <- lm(mean ~ baseline + Group, data = RATSL8S2)
# Compute the analysis of variance table for the fitted model with anova()
anova(fit)
```


## 6.2 Linear mixed effects models for normal response variables





```{r DATACAMP-koodi, eval=FALSE, echo=FALSE}
#### related DATACAMP exercise code below ####
# Read the BPRS data
BPRS <- read.table("https://raw.githubusercontent.com/KimmoVehkalahti/MABS/master/Examples/data/BPRS.txt", sep  =" ", header = T)
# Look at the (column) names of BPRS
names(BPRS)
# Look at the structure of BPRS
str(BPRS)
# Print out summaries of the variables
summary(BPRS)

###

# The data BPRS is available
# Access the packages dplyr and tidyr
library(dplyr)
library(tidyr)
# Factor treatment & subject
BPRS$treatment <- factor(BPRS$treatment)
BPRS$subject <- factor(BPRS$subject)
# Convert to long form
BPRSL <-  BPRS %>% gather(key = weeks, value = bprs, -treatment, -subject)
# Extract the week number
BPRSL <-  BPRSL %>% mutate(week = as.integer(substr(BPRSL$week,5,6)))
# Take a glimpse at the BPRSL data
glimpse(BPRSL)

###

# dplyr, tidyr packages and BPRSL are available
#Access the package ggplot2
library(ggplot2)
# Draw the plot
ggplot(BPRSL, aes(x = week, y = bprs, linetype = subject)) +
  geom_line() +
  scale_linetype_manual(values = rep(1:10, times=4)) +
  facet_grid(. ~ treatment, labeller = label_both) +
  theme(legend.position = "none") + 
  scale_y_continuous(limits = c(min(BPRSL$bprs), max(BPRSL$bprs)))
###

# dplyr, tidyr and ggplot2 packages and BPRSL are available
# Standardise the variable bprs
BPRSL <- BPRSL %>%
  group_by(week) %>%
  mutate(stdbprs = (bprs - mean(bprs))/sd(bprs) ) %>%
  ungroup()
# Glimpse the data
glimpse(BPRSL)
# Plot again with the standardised bprs
ggplot(BPRSL, aes(x = week, y = stdbprs, linetype = subject)) +
  geom_line() +
  scale_linetype_manual(values = rep(1:10, times=4)) +
  facet_grid(. ~ treatment, labeller = label_both) +
  scale_y_continuous(name = "standardized bprs")

###

# dplyr, tidyr & ggplot2 packages and BPRSL are available
# Number of weeks, baseline (week 0) included
n <- BPRSL$week %>% unique() %>% length()
# Summary data with mean and standard error of bprs by treatment and week 
BPRSS <- BPRSL %>%
  group_by(treatment, week) %>%
  summarise( mean = mean(bprs), se = sd(bprs)/sqrt(n) ) %>%
  ungroup()
# Glimpse the data
glimpse(BPRSS)
# Plot the mean profiles
ggplot(BPRSS, aes(x = week, y = mean, linetype = treatment, shape = treatment)) +
  geom_line() +
  scale_linetype_manual(values = c(1,2)) +
  geom_point(size=3) +
  scale_shape_manual(values = c(1,2)) +
  #geom_errorbar(aes(ymin=mean-se, ymax=mean+se, linetype="1"), width=0.3) +
  theme(legend.position = c(0.8,0.8)) +
  scale_y_continuous(name = "mean(bprs) +/- se(bprs)")

###

# dplyr, tidyr & ggplot2 packages and BPRSL are available
# Create a summary data by treatment and subject with mean as the summary variable (ignoring baseline week 0).
BPRSL8S <- BPRSL %>%
  filter(week > 0) %>%
  group_by(treatment, subject) %>%
  summarise( mean=mean(bprs) ) %>%
  ungroup()
# Glimpse the data
glimpse(BPRSL8S)
# Create a new data by filtering the outlier and adjust the ggplot code the draw the plot again with the new data
BPRSL8S1 <- BPRSL8S %>% filter(mean<70)
# Draw a boxplot of the mean versus treatment
ggplot(BPRSL8S1, aes(x = treatment, y = mean)) +
  geom_boxplot() +
  stat_summary(fun.y = "mean", geom = "point", shape=23, size=4, fill = "white") +
  scale_y_continuous(name = "mean(bprs), weeks 1-8")

###

# dplyr, tidyr & ggplot2 packages and BPRSL8S & BPRSL8S1 data are available
# Perform a two-sample t-test
t.test(mean ~ treatment, data = BPRSL8S1, var.equal = TRUE)
# Add the baseline from the original data as a new variable to the summary data
BPRSL8S2 <- BPRSL8S %>%
  mutate(baseline = BPRS$week0)
# Fit the linear model with the mean as the response 
fit <- lm(mean ~ baseline + treatment, data = BPRSL8S2)
# Compute the analysis of variance table for the fitted model with anova()
anova(fit)

###

# PART 2: Chapter 9 for RATS

# dplyr is available
# read the RATS data
RATS <- read.table("https://raw.githubusercontent.com/KimmoVehkalahti/MABS/master/Examples/data/rats.txt", header = TRUE, sep = '\t')
# Factor variables ID and Group
RATS$ID <- as.factor(RATS$ID)
RATS$Group <- as.factor(RATS$Group)
# Glimpse the data
glimpse(RATS)

###

# dplyr, tidyr and RATS are available
# Convert data to long form
RATSL <- RATS %>%
  gather(key = WD, value = Weight, -ID, -Group) %>%
  mutate(Time = as.integer(substr(WD,3,4))) 
# Glimpse the data
glimpse(RATSL)

###

# dplyr, tidyr and RATSL are available
# Check the dimensions of the data
dim(RATSL)
# Plot the RATSL data
ggplot(RATSL, aes(x = Time, y = Weight, group = ID)) +
  geom_line(aes(linetype=Group))+scale_x_continuous(name = "Time (days)", breaks = seq(0, 60, 10))+scale_y_continuous(name = "Weight (grams)")+theme(legend.position = "top")

### 

# dplyr, tidyr, RATS and RATSL are available
# create a regression model RATS_reg
RATS_reg <- lm(Weight ~Time+Group, data=RATSL)
# print out a summary of the model
summary(RATS_reg)

###

# dplyr, tidyr, RATS and RATSL are available
# access library lme4
library(lme4)
# Create a random intercept model
RATS_ref <- lmer(Weight ~ Time + Group + (1 | ID), data = RATSL, REML = FALSE)
# Print the summary of the model
summary(RATS_ref)

###

# dplyr, tidyr, lme4, ggplot2, RATS and RATSL are available
# create a random intercept and random slope model
RATS_ref1 <- lmer(Weight ~ Time + Group + (Time | ID), data = RATSL, REML = FALSE)
# print a summary of the model
summary(RATS_ref)
# perform an ANOVA test on the two models
anova(RATS_ref1, RATS_ref)

###

# dplyr, tidyr, lme4, ggplot2, RATS and RATSL are available
# create a random intercept and random slope model with the interaction
RATS_ref2 <- lmer(Weight ~ Time + Group + Time*Group + (Time | ID), data = RATSL, REML = FALSE)
# print a summary of the model
summary(RATS_ref2)
# perform an ANOVA test on the two models
anova(RATS_ref2, RATS_ref1)
# draw the plot of RATSL with the observed Weight values
ggplot(RATSL, aes(x = Time, y = Weight, group = ID)) +
  geom_line(aes(linetype = Group)) +
  scale_x_continuous(name = "Time (days)", breaks = seq(0, 60, 20)) +
  scale_y_continuous(name = "Observed weight (grams)") +
  theme(legend.position = "top")
# Create a vector of the fitted values
Fitted <- fitted(RATS_ref2)
# Create a new column fitted to RATSL
RATSL$fitted <- Fitted
# draw the plot of RATSL with the Fitted values of weight
ggplot(RATSL, aes(x = Time, y = fitted, group = ID)) +
  geom_line(aes(linetype = Group)) +
  scale_x_continuous(name = "Time (days)", breaks = seq(0, 60, 20)) +
  scale_y_continuous(name = "Fitted weight (grams)") +
  theme(legend.position = "top")
```
